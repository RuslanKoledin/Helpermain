<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä - {{ scenario.title }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #e94560;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .scenario-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-save {
            background: linear-gradient(135deg, #4CAF50, #388E3C);
            color: white;
        }

        .btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn-add {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
        }

        .btn-add:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        /* Canvas Container */
        .canvas-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 300px;
            bottom: 0;
            overflow: auto;
            background:
                radial-gradient(circle, #1a1a2e 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
            cursor: grab;
        }

        .canvas:active {
            cursor: grabbing;
        }

        /* SVG for connections */
        .connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .connection-line {
            stroke: #e94560;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .connection-line.creating {
            stroke-dasharray: 5, 5;
            opacity: 0.7;
        }

        /* Nodes */
        .node {
            position: absolute;
            min-width: 200px;
            max-width: 300px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            cursor: move;
            user-select: none;
        }

        .node.selected {
            box-shadow: 0 0 0 3px #e94560, 0 4px 20px rgba(0,0,0,0.3);
        }

        .node-header {
            padding: 12px 15px;
            border-radius: 12px 12px 0 0;
            color: white;
            font-weight: 600;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .node-type-client .node-header {
            background: linear-gradient(135deg, #2196F3, #1976D2);
        }

        .node-type-answer .node-header {
            background: linear-gradient(135deg, #4CAF50, #388E3C);
        }

        .node-type-condition .node-header {
            background: linear-gradient(135deg, #FF9800, #F57C00);
        }

        .node-type-end .node-header {
            background: linear-gradient(135deg, #f44336, #D32F2F);
        }

        .node-type-start .node-header {
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
        }

        .node-body {
            padding: 12px 15px;
            font-size: 13px;
            color: #333;
            line-height: 1.5;
            max-height: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-footer {
            padding: 8px 15px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .node-step-num {
            font-size: 11px;
            color: #999;
        }

        .node-delete {
            padding: 4px 8px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .node:hover .node-delete {
            opacity: 1;
        }

        /* Connection points */
        .conn-point {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #e94560;
            border: 2px solid white;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 10;
        }

        .conn-point.input {
            top: 50%;
            left: -7px;
            transform: translateY(-50%);
        }

        .conn-point.output {
            top: 50%;
            right: -7px;
            transform: translateY(-50%);
        }

        .conn-point:hover {
            transform: translateY(-50%) scale(1.3);
            background: #ff6b8a;
        }

        /* Properties Panel */
        .properties-panel {
            position: fixed;
            top: 60px;
            right: 0;
            bottom: 0;
            width: 300px;
            background: #16213e;
            border-left: 2px solid #e94560;
            padding: 20px;
            overflow-y: auto;
            color: white;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .panel-empty {
            text-align: center;
            color: rgba(255,255,255,0.5);
            padding: 40px 20px;
        }

        .prop-group {
            margin-bottom: 20px;
        }

        .prop-label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 6px;
            display: block;
        }

        .prop-input,
        .prop-textarea,
        .prop-select {
            width: 100%;
            padding: 10px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            font-size: 13px;
        }

        .prop-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .prop-input:focus,
        .prop-textarea:focus,
        .prop-select:focus {
            outline: none;
            border-color: #e94560;
        }

        .prop-select option {
            background: #16213e;
        }

        /* Toolbar */
        .toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .toolbar-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 15px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .toolbar-btn .icon {
            font-size: 24px;
        }

        .toolbar-btn .label {
            font-size: 11px;
            opacity: 0.7;
        }

        .toolbar-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toolbar-divider {
            width: 1px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            margin: 0 5px;
        }

        .history-info {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            padding: 0 10px;
            display: flex;
            align-items: center;
        }

        /* Zoom controls */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 320px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .zoom-level {
            padding: 8px 12px;
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: white;
            font-size: 13px;
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 80px;
            right: 320px;
            width: 150px;
            height: 100px;
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .minimap-viewport {
            position: absolute;
            border: 2px solid #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .minimap-node {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 1px;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border-radius: 8px;
            font-size: 14px;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
        }

        .toast.error {
            background: #f44336;
        }

        /* Answers list inside node */
        .node-answers {
            padding: 0 15px 10px;
        }

        .node-answer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            margin-bottom: 4px;
            background: #f5f5f5;
            border-radius: 6px;
            font-size: 12px;
        }

        .node-answer-item.correct {
            background: #e8f5e9;
            border-left: 3px solid #4CAF50;
        }

        .node-answer-item.partial {
            background: #fff3e0;
            border-left: 3px solid #FF9800;
        }

        .node-answer-item.wrong {
            background: #ffebee;
            border-left: 3px solid #f44336;
        }

        /* Help overlay */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .help-overlay.show {
            display: flex;
        }

        .help-content {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            color: #333;
        }

        .help-content h2 {
            margin-bottom: 20px;
        }

        .help-content ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .help-close {
            margin-top: 20px;
            padding: 10px 30px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        /* Answer Editor Styles */
        .answers-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .answer-edit-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .answer-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .answer-num {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            font-weight: 600;
        }

        .answer-delete-btn {
            background: #f44336;
            color: white;
            border: none;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .answer-edit-item .prop-textarea {
            min-height: 60px;
            margin-bottom: 8px;
        }

        .answer-options {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .answer-option {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .answer-option input[type="radio"] {
            margin: 0;
        }

        .option-correct { color: #4CAF50; }
        .option-partial { color: #FF9800; }
        .option-wrong { color: #f44336; }

        .answer-points {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }

        .answer-points label {
            display: flex;
            align-items: center;
            gap: 6px;
            color: rgba(255,255,255,0.7);
        }

        .prop-input-small {
            width: 60px;
            padding: 6px 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            color: white;
            font-size: 12px;
        }

        .btn-add-answer {
            width: 100%;
            padding: 10px;
            background: rgba(33, 150, 243, 0.2);
            border: 1px dashed rgba(33, 150, 243, 0.5);
            border-radius: 8px;
            color: #2196F3;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-add-answer:hover {
            background: rgba(33, 150, 243, 0.3);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <a href="{{ url_for('admin_trainer_edit', scenario_id=scenario.id) }}" class="back-btn">
                &larr; –ù–∞–∑–∞–¥
            </a>
            <span class="scenario-title">{{ scenario.title }}</span>
        </div>
        <div class="header-actions">
            <button class="btn btn-add" onclick="showHelp()">?</button>
            <a href="{{ url_for('trainer_play', scenario_id=scenario.id) }}?preview=1" class="btn" style="background: linear-gradient(135deg, #FF9800, #F57C00); color: white;">üëÅÔ∏è –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä</a>
            <button class="btn btn-save" onclick="saveScenario()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        </div>
    </div>

    <!-- Canvas -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas" id="canvas">
            <svg class="connections-svg" id="connectionsSvg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#e94560" />
                    </marker>
                </defs>
            </svg>
            <!-- Nodes will be added here dynamically -->
        </div>
    </div>

    <!-- Properties Panel -->
    <div class="properties-panel" id="propertiesPanel">
        <div class="panel-title">–°–≤–æ–π—Å—Ç–≤–∞</div>
        <div class="panel-empty" id="panelEmpty">
            –í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        </div>
        <div id="panelContent" style="display: none;">
            <!-- Dynamic content -->
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button class="toolbar-btn" id="undoBtn" onclick="undo()" title="–û—Ç–º–µ–Ω–∏—Ç—å (Ctrl+Z)">
            <span class="icon">‚Ü©Ô∏è</span>
            <span class="label">–û—Ç–º–µ–Ω–∏—Ç—å</span>
        </button>
        <button class="toolbar-btn" id="redoBtn" onclick="redo()" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (Ctrl+Y)">
            <span class="icon">‚Ü™Ô∏è</span>
            <span class="label">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å</span>
        </button>
        <span class="toolbar-divider"></span>
        <button class="toolbar-btn" onclick="addNode('client')">
            <span class="icon">üí¨</span>
            <span class="label">–†–µ–ø–ª–∏–∫–∞</span>
        </button>
        <button class="toolbar-btn" onclick="addNode('answer')">
            <span class="icon">‚úÖ</span>
            <span class="label">–û—Ç–≤–µ—Ç</span>
        </button>
        <button class="toolbar-btn" onclick="addNode('condition')">
            <span class="icon">‚ùì</span>
            <span class="label">–£—Å–ª–æ–≤–∏–µ</span>
        </button>
        <button class="toolbar-btn" onclick="addNode('end')">
            <span class="icon">üèÅ</span>
            <span class="label">–ö–æ–Ω–µ—Ü</span>
        </button>
        <span class="toolbar-divider"></span>
        <button class="toolbar-btn" onclick="copyNode()" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (Ctrl+C)">
            <span class="icon">üìã</span>
            <span class="label">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</span>
        </button>
        <button class="toolbar-btn" onclick="pasteNode()" title="–í—Å—Ç–∞–≤–∏—Ç—å (Ctrl+V)">
            <span class="icon">üìÑ</span>
            <span class="label">–í—Å—Ç–∞–≤–∏—Ç—å</span>
        </button>
        <button class="toolbar-btn" onclick="autoLayout()" title="–ê–≤—Ç–æ-—Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ">
            <span class="icon">üîÄ</span>
            <span class="label">–ê–≤—Ç–æ</span>
        </button>
        <span class="toolbar-divider"></span>
        <span class="history-info" id="historyInfo">1/1</span>
    </div>

    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomOut()">-</button>
        <span class="zoom-level" id="zoomLevel">100%</span>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Help Overlay -->
    <div class="help-overlay" id="helpOverlay">
        <div class="help-content">
            <h2>–°–ø—Ä–∞–≤–∫–∞ –ø–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä—É</h2>
            <ul>
                <li><strong>–ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ:</strong> –ó–∞–∂–º–∏—Ç–µ –∏ —Ç—è–Ω–∏—Ç–µ —É–∑–ª—ã</li>
                <li><strong>–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ:</strong> –ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ç–æ—á–∫—É –≤—ã—Ö–æ–¥–∞ –∏ —Ç—è–Ω–∏—Ç–µ –∫ —Ç–æ—á–∫–µ –≤—Ö–æ–¥–∞</li>
                <li><strong>–í—ã–±–æ—Ä:</strong> –ö–ª–∏–∫ –ø–æ —É–∑–ª—É –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤</li>
                <li><strong>–£–¥–∞–ª–µ–Ω–∏–µ:</strong> –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ –∫–ª–∞–≤–∏—à–∞ Delete</li>
                <li><strong>–ú–∞—Å—à—Ç–∞–±:</strong> –ö–æ–ª–µ—Å–æ –º—ã—à–∏ + Ctrl –∏–ª–∏ –∫–Ω–æ–ø–∫–∏ +/-</li>
            </ul>
            <p style="margin-top: 15px; color: #666;">
                <strong>–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏:</strong><br>
                Ctrl+Z ‚Äî –û—Ç–º–µ–Ω–∏—Ç—å | Ctrl+Y ‚Äî –ü–æ–≤—Ç–æ—Ä–∏—Ç—å<br>
                Ctrl+C ‚Äî –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å | Ctrl+V ‚Äî –í—Å—Ç–∞–≤–∏—Ç—å<br>
                Ctrl+D ‚Äî –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å | Ctrl+S ‚Äî –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </p>
            <p style="margin-top: 15px; color: #666;">
                <strong>–¢–∏–ø—ã —É–∑–ª–æ–≤:</strong><br>
                –†–µ–ø–ª–∏–∫–∞ (—Å–∏–Ω–∏–π) - —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞<br>
                –û—Ç–≤–µ—Ç (–∑–µ–ª–µ–Ω—ã–π) - –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞<br>
                –£—Å–ª–æ–≤–∏–µ (–æ—Ä–∞–Ω–∂–µ–≤—ã–π) - –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π<br>
                –ö–æ–Ω–µ—Ü (–∫—Ä–∞—Å–Ω—ã–π) - –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏—è
            </p>
            <button class="help-close" onclick="hideHelp()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script>
        const scenarioId = {{ scenario.id }};
        const csrfToken = '{{ csrf_token() }}';

        // State
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let draggingNode = null;
        let dragOffset = { x: 0, y: 0 };
        let creatingConnection = null;
        let zoom = 1;
        let pan = { x: 0, y: 0 };
        let nodeIdCounter = 1;

        // === UNDO/REDO SYSTEM ===
        let history = [];           // Array of states
        let historyIndex = -1;      // Current position
        const MAX_HISTORY = 50;     // Maximum steps

        // === CLIPBOARD ===
        let clipboard = null;       // { node: {...}, type: 'single' }

        // Elements
        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const connectionsSvg = document.getElementById('connectionsSvg');
        const propertiesPanel = document.getElementById('propertiesPanel');
        const panelContent = document.getElementById('panelContent');
        const panelEmpty = document.getElementById('panelEmpty');

        // Initialize with existing steps
        {% for step in steps %}
        nodes.push({
            id: 'step_{{ step.id }}',
            type: 'client',
            x: {{ loop.index * 250 }},
            y: 100,
            data: {
                stepId: {{ step.id }},
                stepNum: {{ step.step_num }},
                message: {{ step.client_message | tojson }},
                avatar: {{ step.client_avatar | tojson }},
                clientName: {{ step.client_name | tojson }},
                mood: {{ step.initial_mood | tojson if step.initial_mood else '"neutral"' }},
                answers: [
                    {% for answer in step.answers %}
                    {
                        id: {{ answer.id }},
                        text: {{ answer.answer_text | tojson }},
                        isCorrect: {{ 'true' if answer.is_correct else 'false' }},
                        isPartial: {{ 'true' if answer.is_partial else 'false' }},
                        points: {{ answer.points }},
                        moodImpact: {{ answer.mood_impact or 0 }}
                    }{{ ',' if not loop.last else '' }}
                    {% endfor %}
                ]
            }
        });
        nodeIdCounter = Math.max(nodeIdCounter, {{ step.id }} + 1);
        {% endfor %}

        // Try to load saved visual data first, fallback to generated data
        async function loadVisualData() {
            try {
                const response = await fetch(`/admin/trainer/scenario/${scenarioId}/visual/load`);
                const result = await response.json();

                if (result.success && result.nodes && result.nodes.length > 0) {
                    // Use saved visual data
                    nodes = result.nodes.map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        data: {
                            message: n.label || '',
                            mood: n.mood || 'neutral',
                            answers: n.answers || [],
                            condition: n.condition || '',
                            endType: n.endType || 'success',
                            stepId: n.stepId,
                            stepNum: n.stepNum,
                            clientName: n.clientName || '–ö–ª–∏–µ–Ω—Ç',
                            isCorrect: n.isCorrect || false,
                            moodImpact: n.moodImpact || 0,
                            feedback: n.feedback || '',
                            knowledgeLink: n.knowledgeLink || ''
                        }
                    }));

                    connections = result.connections.map(c => ({
                        from: c.fromId,
                        to: c.toId
                    }));

                    // Update node counter
                    nodes.forEach(n => {
                        const idNum = parseInt(n.id.replace(/\D/g, '')) || 0;
                        nodeIdCounter = Math.max(nodeIdCounter, idNum + 1);
                    });
                }
            } catch (e) {
                console.log('Using initial data from steps');
            }

            renderNodes();
            updateConnections();
        }

        // Load data
        loadVisualData().then(() => {
            // Save initial state for undo
            saveState();
        });

        // === UNDO/REDO FUNCTIONS ===
        function saveState() {
            // Copy current state
            const state = JSON.parse(JSON.stringify({ nodes, connections }));

            // Trim "future" if we did undo then made changes
            history = history.slice(0, historyIndex + 1);
            history.push(state);

            if (history.length > MAX_HISTORY) history.shift();
            historyIndex = history.length - 1;

            updateHistoryUI();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                showToast('–û—Ç–º–µ–Ω–µ–Ω–æ');
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                showToast('–ü–æ–≤—Ç–æ—Ä–µ–Ω–æ');
            }
        }

        function restoreState(state) {
            nodes = JSON.parse(JSON.stringify(state.nodes));
            connections = JSON.parse(JSON.stringify(state.connections));

            // Update nodeIdCounter
            nodes.forEach(n => {
                const idNum = parseInt(n.id.replace(/\D/g, '')) || 0;
                nodeIdCounter = Math.max(nodeIdCounter, idNum + 1);
            });

            renderNodes();
            updateConnections();
            updateHistoryUI();

            // Deselect
            selectedNode = null;
            panelEmpty.style.display = 'block';
            panelContent.style.display = 'none';
        }

        function updateHistoryUI() {
            const historyInfo = document.getElementById('historyInfo');
            if (historyInfo) {
                historyInfo.textContent = `${historyIndex + 1}/${history.length}`;
            }
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = historyIndex <= 0;
            if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // === COPY/PASTE FUNCTIONS ===
        function copyNode() {
            if (!selectedNode) {
                showToast('–í—ã–±–µ—Ä–∏—Ç–µ —É–∑–µ–ª –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', true);
                return;
            }
            clipboard = {
                type: 'single',
                node: JSON.parse(JSON.stringify(selectedNode))
            };
            showToast('–£–∑–µ–ª —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω');
        }

        function pasteNode() {
            if (!clipboard) {
                showToast('–ë—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ –ø—É—Å—Ç', true);
                return;
            }

            const newNode = JSON.parse(JSON.stringify(clipboard.node));
            newNode.id = `node_${nodeIdCounter++}`;
            newNode.x += 50;  // Offset
            newNode.y += 50;

            // Clear IDs from answers if copying client node
            if (newNode.data && newNode.data.answers) {
                newNode.data.answers = newNode.data.answers.map(a => ({
                    ...a,
                    id: null
                }));
            }
            if (newNode.data) {
                newNode.data.stepId = null;
            }

            nodes.push(newNode);
            saveState();
            renderNodes();
            updateConnections();
            selectNode(newNode);
            showToast('–£–∑–µ–ª –≤—Å—Ç–∞–≤–ª–µ–Ω');
        }

        function duplicateNode() {
            if (!selectedNode) {
                showToast('–í—ã–±–µ—Ä–∏—Ç–µ —É–∑–µ–ª –¥–ª—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è', true);
                return;
            }
            copyNode();
            pasteNode();
        }

        // === AUTO-LAYOUT FUNCTION ===
        function autoLayout() {
            if (!confirm('–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å —É–∑–ª—ã? –¢–µ–∫—É—â–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –±—É–¥—É—Ç –∏–∑–º–µ–Ω–µ–Ω—ã.')) return;

            saveState();

            // Find root nodes (no incoming connections)
            const roots = nodes.filter(n =>
                !connections.some(c => c.to === n.id)
            );

            const LEVEL_HEIGHT = 200;
            const NODE_WIDTH = 280;
            const MARGIN = 50;
            const canvasWidth = 3000;

            let visited = new Set();
            let levels = {};  // { nodeId: level }

            // BFS for level assignment
            function assignLevels(startNodes) {
                let queue = startNodes.map(n => ({ node: n, level: 0 }));

                while (queue.length > 0) {
                    const { node, level } = queue.shift();
                    if (visited.has(node.id)) continue;

                    visited.add(node.id);
                    levels[node.id] = level;

                    // Find children
                    const children = connections
                        .filter(c => c.from === node.id)
                        .map(c => nodes.find(n => n.id === c.to))
                        .filter(Boolean);

                    children.forEach(child => {
                        if (!visited.has(child.id)) {
                            queue.push({ node: child, level: level + 1 });
                        }
                    });
                }
            }

            assignLevels(roots.length > 0 ? roots : (nodes.length > 0 ? [nodes[0]] : []));

            // Group by levels
            const levelGroups = {};
            Object.entries(levels).forEach(([nodeId, level]) => {
                if (!levelGroups[level]) levelGroups[level] = [];
                levelGroups[level].push(nodeId);
            });

            // Position nodes
            Object.entries(levelGroups).forEach(([level, nodeIds]) => {
                const y = parseInt(level) * LEVEL_HEIGHT + MARGIN;
                const totalWidth = nodeIds.length * NODE_WIDTH;
                const startX = Math.max(MARGIN, (canvasWidth - totalWidth) / 2);

                nodeIds.forEach((nodeId, idx) => {
                    const node = nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.x = startX + idx * NODE_WIDTH;
                        node.y = y;
                    }
                });
            });

            // Handle disconnected nodes
            let offsetY = (Object.keys(levelGroups).length) * LEVEL_HEIGHT + MARGIN;
            nodes.filter(n => !levels[n.id]).forEach((node, idx) => {
                node.x = MARGIN + (idx % 4) * NODE_WIDTH;
                node.y = offsetY + Math.floor(idx / 4) * LEVEL_HEIGHT;
            });

            renderNodes();
            updateConnections();
            showToast('–£–∑–ª—ã —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏');
        }

        // Node rendering
        function renderNodes() {
            // Clear existing
            document.querySelectorAll('.node').forEach(n => n.remove());

            nodes.forEach(node => {
                const el = createNodeElement(node);
                canvas.appendChild(el);
            });
        }

        function createNodeElement(node) {
            const el = document.createElement('div');
            el.className = `node node-type-${node.type}`;
            el.id = node.id;
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';

            let headerText = '';
            let bodyText = '';
            let footerText = '';

            switch(node.type) {
                case 'client':
                    headerText = `–†–µ–ø–ª–∏–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞`;
                    bodyText = node.data.message || '–°–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞...';
                    footerText = `–®–∞–≥ ${node.data.stepNum || '?'}`;
                    break;
                case 'answer':
                    headerText = '–û—Ç–≤–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞';
                    bodyText = node.data.text || '–û—Ç–≤–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞...';
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø –æ—Ç–≤–µ—Ç–∞
                    if (node.data.isCorrect) {
                        footerText = '‚úì –í–µ—Ä–Ω—ã–π';
                    } else if (node.data.isPartial) {
                        footerText = '‚óê –ß–∞—Å—Ç–∏—á–Ω–æ';
                    } else {
                        footerText = '‚úó –ù–µ–≤–µ—Ä–Ω—ã–π';
                    }
                    break;
                case 'condition':
                    headerText = '–£—Å–ª–æ–≤–∏–µ';
                    bodyText = node.data.condition || 'if loyalty < 50%';
                    break;
                case 'end':
                    headerText = '–ö–æ–Ω–µ—Ü';
                    bodyText = node.data.endType === 'gameover' ? 'Game Over' : '–£—Å–ø–µ—Ö';
                    break;
                case 'start':
                    headerText = '–ù–∞—á–∞–ª–æ';
                    bodyText = '–°—Ç–∞—Ä—Ç —Å—Ü–µ–Ω–∞—Ä–∏—è';
                    break;
            }

            el.innerHTML = `
                <div class="node-header">
                    <span>${headerText}</span>
                </div>
                <div class="node-body">${escapeHtml(bodyText).substring(0, 150)}${bodyText.length > 150 ? '...' : ''}</div>
                ${node.type === 'client' && node.data.answers && node.data.answers.length > 0 ? `
                    <div class="node-answers">
                        ${node.data.answers.slice(0, 3).map(a => `
                            <div class="node-answer-item ${a.isCorrect ? 'correct' : a.isPartial ? 'partial' : 'wrong'}">
                                ${escapeHtml(a.text).substring(0, 30)}...
                            </div>
                        `).join('')}
                        ${node.data.answers.length > 3 ? `<div style="font-size: 11px; color: #999;">+${node.data.answers.length - 3} –µ—â—ë</div>` : ''}
                    </div>
                ` : ''}
                <div class="node-footer">
                    <span class="node-step-num">${footerText}</span>
                    <button class="node-delete" onclick="deleteNode('${node.id}')">–£–¥–∞–ª–∏—Ç—å</button>
                </div>
                <div class="conn-point input" data-node="${node.id}" data-type="input"></div>
                <div class="conn-point output" data-node="${node.id}" data-type="output"></div>
            `;

            // Event listeners
            el.addEventListener('mousedown', (e) => startDrag(e, node));
            el.addEventListener('click', (e) => selectNode(node, e));

            // Connection point listeners
            el.querySelectorAll('.conn-point').forEach(point => {
                point.addEventListener('mousedown', (e) => startConnection(e, node, point.dataset.type));
            });

            return el;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }

        // Drag handling
        function startDrag(e, node) {
            if (e.target.classList.contains('conn-point') || e.target.classList.contains('node-delete')) return;

            draggingNode = node;
            const rect = document.getElementById(node.id).getBoundingClientRect();
            const containerRect = canvasContainer.getBoundingClientRect();

            dragOffset.x = e.clientX - rect.left + canvasContainer.scrollLeft;
            dragOffset.y = e.clientY - rect.top + canvasContainer.scrollTop;

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        function onDrag(e) {
            if (!draggingNode) return;

            const containerRect = canvasContainer.getBoundingClientRect();
            const x = e.clientX - containerRect.left + canvasContainer.scrollLeft - dragOffset.x + 100;
            const y = e.clientY - containerRect.top + canvasContainer.scrollTop - dragOffset.y + 50;

            draggingNode.x = Math.max(0, x);
            draggingNode.y = Math.max(0, y);

            const el = document.getElementById(draggingNode.id);
            el.style.left = draggingNode.x + 'px';
            el.style.top = draggingNode.y + 'px';

            updateConnections();
        }

        function stopDrag() {
            draggingNode = null;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // Connection handling
        function startConnection(e, node, type) {
            e.stopPropagation();
            if (type !== 'output') return;

            creatingConnection = {
                fromNode: node,
                fromX: node.x + 200, // right side of node
                fromY: node.y + 50  // middle
            };

            document.addEventListener('mousemove', onCreateConnection);
            document.addEventListener('mouseup', stopConnection);
        }

        function onCreateConnection(e) {
            if (!creatingConnection) return;

            const containerRect = canvasContainer.getBoundingClientRect();
            const toX = e.clientX - containerRect.left + canvasContainer.scrollLeft;
            const toY = e.clientY - containerRect.top + canvasContainer.scrollTop;

            // Draw temporary line
            let tempLine = connectionsSvg.querySelector('.temp-line');
            if (!tempLine) {
                tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                tempLine.classList.add('connection-line', 'creating', 'temp-line');
                connectionsSvg.appendChild(tempLine);
            }

            const path = createCurvePath(
                creatingConnection.fromX,
                creatingConnection.fromY,
                toX,
                toY
            );
            tempLine.setAttribute('d', path);
        }

        function stopConnection(e) {
            const tempLine = connectionsSvg.querySelector('.temp-line');
            if (tempLine) tempLine.remove();

            // Check if dropped on input point
            const target = document.elementFromPoint(e.clientX, e.clientY);
            if (target && target.classList.contains('conn-point') && target.dataset.type === 'input') {
                const toNodeId = target.dataset.node;
                const toNode = nodes.find(n => n.id === toNodeId);

                if (toNode && toNode.id !== creatingConnection.fromNode.id) {
                    connections.push({
                        from: creatingConnection.fromNode.id,
                        to: toNode.id
                    });
                    saveState();
                    updateConnections();
                }
            }

            creatingConnection = null;
            document.removeEventListener('mousemove', onCreateConnection);
            document.removeEventListener('mouseup', stopConnection);
        }

        function createCurvePath(x1, y1, x2, y2) {
            const midX = (x1 + x2) / 2;
            return `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
        }

        function updateConnections() {
            // Clear existing connection lines
            connectionsSvg.querySelectorAll('.connection-line:not(.temp-line)').forEach(l => l.remove());

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);

                if (!fromNode || !toNode) return;

                const fromEl = document.getElementById(fromNode.id);
                const toEl = document.getElementById(toNode.id);

                if (!fromEl || !toEl) return;

                const x1 = fromNode.x + fromEl.offsetWidth;
                const y1 = fromNode.y + fromEl.offsetHeight / 2;
                const x2 = toNode.x;
                const y2 = toNode.y + toEl.offsetHeight / 2;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.classList.add('connection-line');
                line.setAttribute('d', createCurvePath(x1, y1, x2, y2));
                connectionsSvg.appendChild(line);
            });
        }

        // Node selection
        function selectNode(node, e) {
            if (e) e.stopPropagation();

            // Deselect previous
            document.querySelectorAll('.node.selected').forEach(n => n.classList.remove('selected'));

            selectedNode = node;
            document.getElementById(node.id).classList.add('selected');

            showProperties(node);
        }

        function showProperties(node) {
            panelEmpty.style.display = 'none';
            panelContent.style.display = 'block';

            let html = '';

            switch(node.type) {
                case 'client':
                    const answers = node.data.answers || [];
                    let answersHtml = answers.map((a, idx) => `
                        <div class="answer-edit-item" data-idx="${idx}">
                            <div class="answer-edit-header">
                                <span class="answer-num">#${idx + 1}</span>
                                <button class="answer-delete-btn" onclick="deleteAnswer(${idx})">‚úï</button>
                            </div>
                            <textarea class="prop-textarea answer-text" placeholder="–¢–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞" onchange="updateAnswer(${idx}, 'text', this.value)">${escapeHtml(a.text || '')}</textarea>
                            <div class="answer-options">
                                <label class="answer-option">
                                    <input type="radio" name="answer_type_${idx}" value="correct" ${a.isCorrect ? 'checked' : ''} onchange="setAnswerType(${idx}, 'correct')">
                                    <span class="option-correct">–í–µ—Ä–Ω—ã–π</span>
                                </label>
                                <label class="answer-option">
                                    <input type="radio" name="answer_type_${idx}" value="partial" ${a.isPartial ? 'checked' : ''} onchange="setAnswerType(${idx}, 'partial')">
                                    <span class="option-partial">–ß–∞—Å—Ç–∏—á–Ω–æ</span>
                                </label>
                                <label class="answer-option">
                                    <input type="radio" name="answer_type_${idx}" value="wrong" ${!a.isCorrect && !a.isPartial ? 'checked' : ''} onchange="setAnswerType(${idx}, 'wrong')">
                                    <span class="option-wrong">–ù–µ–≤–µ—Ä–Ω—ã–π</span>
                                </label>
                            </div>
                            <div class="answer-points">
                                <label>–ë–∞–ª–ª—ã: <input type="number" class="prop-input-small" value="${a.points || 0}" onchange="updateAnswer(${idx}, 'points', parseInt(this.value))"></label>
                                <label>–í–ª–∏—è–Ω–∏–µ: <input type="number" class="prop-input-small" value="${a.moodImpact || 0}" onchange="updateAnswer(${idx}, 'moodImpact', parseInt(this.value))"></label>
                            </div>
                        </div>
                    `).join('');

                    html = `
                        <div class="prop-group">
                            <label class="prop-label">–°–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞</label>
                            <textarea class="prop-textarea" onchange="updateNodeData('message', this.value)">${escapeHtml(node.data.message || '')}</textarea>
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–ò–º—è –∫–ª–∏–µ–Ω—Ç–∞</label>
                            <input class="prop-input" value="${escapeHtml(node.data.clientName || '–ö–ª–∏–µ–Ω—Ç')}" onchange="updateNodeData('clientName', this.value)">
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–ù–∞—á–∞–ª—å–Ω–∞—è —ç–º–æ—Ü–∏—è</label>
                            <select class="prop-select" onchange="updateNodeData('mood', this.value)">
                                <option value="neutral" ${node.data.mood === 'neutral' ? 'selected' : ''}>–ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ</option>
                                <option value="anger" ${node.data.mood === 'anger' ? 'selected' : ''}>–ì–Ω–µ–≤</option>
                                <option value="irritation" ${node.data.mood === 'irritation' ? 'selected' : ''}>–†–∞–∑–¥—Ä–∞–∂–µ–Ω–∏–µ</option>
                                <option value="satisfaction" ${node.data.mood === 'satisfaction' ? 'selected' : ''}>–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–∏–µ</option>
                                <option value="delight" ${node.data.mood === 'delight' ? 'selected' : ''}>–í–æ—Å—Ç–æ—Ä–≥</option>
                            </select>
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ (${answers.length})</label>
                            <div class="answers-list">
                                ${answersHtml}
                            </div>
                            <button class="btn-add-answer" onclick="addAnswer()">+ –î–æ–±–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç</button>
                        </div>
                    `;
                    break;
                case 'condition':
                    html = `
                        <div class="prop-group">
                            <label class="prop-label">–£—Å–ª–æ–≤–∏–µ</label>
                            <input class="prop-input" value="${escapeHtml(node.data.condition || '')}" onchange="updateNodeData('condition', this.value)" placeholder="if loyalty < 50%">
                        </div>
                    `;
                    break;
                case 'answer':
                    html = `
                        <div class="prop-group">
                            <label class="prop-label">–¢–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞</label>
                            <textarea class="prop-textarea" onchange="updateNodeData('text', this.value)">${escapeHtml(node.data.text || '')}</textarea>
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–¢–∏–ø –æ—Ç–≤–µ—Ç–∞</label>
                            <div class="answer-options" style="flex-direction: column; gap: 8px;">
                                <label class="answer-option">
                                    <input type="radio" name="answer_type_single" value="correct" ${node.data.isCorrect ? 'checked' : ''} onchange="updateNodeData('isCorrect', true); updateNodeData('isPartial', false);">
                                    <span class="option-correct">–í–µ—Ä–Ω—ã–π (+10 –±–∞–ª–ª–æ–≤)</span>
                                </label>
                                <label class="answer-option">
                                    <input type="radio" name="answer_type_single" value="partial" ${node.data.isPartial ? 'checked' : ''} onchange="updateNodeData('isCorrect', false); updateNodeData('isPartial', true);">
                                    <span class="option-partial">–ß–∞—Å—Ç–∏—á–Ω–æ –≤–µ—Ä–Ω—ã–π (+5 –±–∞–ª–ª–æ–≤)</span>
                                </label>
                                <label class="answer-option">
                                    <input type="radio" name="answer_type_single" value="wrong" ${!node.data.isCorrect && !node.data.isPartial ? 'checked' : ''} onchange="updateNodeData('isCorrect', false); updateNodeData('isPartial', false);">
                                    <span class="option-wrong">–ù–µ–≤–µ—Ä–Ω—ã–π (0 –±–∞–ª–ª–æ–≤)</span>
                                </label>
                            </div>
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–ë–∞–ª–ª—ã</label>
                            <input type="number" class="prop-input" value="${node.data.points || 0}" onchange="updateNodeData('points', parseInt(this.value))">
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–í–ª–∏—è–Ω–∏–µ –Ω–∞ –ª–æ—è–ª—å–Ω–æ—Å—Ç—å</label>
                            <select class="prop-select" onchange="updateNodeData('moodImpact', parseInt(this.value))">
                                <option value="10" ${node.data.moodImpact === 10 ? 'selected' : ''}>+10 (–û—Ç–ª–∏—á–Ω–æ)</option>
                                <option value="5" ${node.data.moodImpact === 5 ? 'selected' : ''}>+5 (–•–æ—Ä–æ—à–æ)</option>
                                <option value="0" ${node.data.moodImpact === 0 || !node.data.moodImpact ? 'selected' : ''}>0 (–ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ)</option>
                                <option value="-10" ${node.data.moodImpact === -10 ? 'selected' : ''}>-10 (–ü–ª–æ—Ö–æ)</option>
                                <option value="-20" ${node.data.moodImpact === -20 ? 'selected' : ''}>-20 (–û—á–µ–Ω—å –ø–ª–æ—Ö–æ)</option>
                                <option value="-100" ${node.data.moodImpact === -100 ? 'selected' : ''}>-100 (Game Over)</option>
                            </select>
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å (feedback)</label>
                            <textarea class="prop-textarea" placeholder="–ü–æ—á–µ–º—É —ç—Ç–æ—Ç –æ—Ç–≤–µ—Ç –≤–µ—Ä–Ω—ã–π/–Ω–µ–≤–µ—Ä–Ω—ã–π" onchange="updateNodeData('feedback', this.value)">${escapeHtml(node.data.feedback || '')}</textarea>
                        </div>
                        <div class="prop-group">
                            <label class="prop-label">–°—Å—ã–ª–∫–∞ –Ω–∞ –ë–∞–∑—É –ó–Ω–∞–Ω–∏–π</label>
                            <input class="prop-input" placeholder="https://..." value="${escapeHtml(node.data.knowledgeLink || '')}" onchange="updateNodeData('knowledgeLink', this.value)">
                        </div>
                    `;
                    break;
                case 'end':
                    html = `
                        <div class="prop-group">
                            <label class="prop-label">–¢–∏–ø –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è</label>
                            <select class="prop-select" onchange="updateNodeData('endType', this.value)">
                                <option value="success" ${node.data.endType !== 'gameover' ? 'selected' : ''}>–£—Å–ø–µ—Ö</option>
                                <option value="gameover" ${node.data.endType === 'gameover' ? 'selected' : ''}>Game Over</option>
                            </select>
                        </div>
                    `;
                    break;
            }

            panelContent.innerHTML = html;
        }

        function updateNodeData(key, value) {
            if (!selectedNode) return;
            selectedNode.data[key] = value;
            saveState();
            renderNodes();
            selectNode(selectedNode);
        }

        // Answer management functions
        function addAnswer() {
            if (!selectedNode || selectedNode.type !== 'client') return;
            if (!selectedNode.data.answers) selectedNode.data.answers = [];

            selectedNode.data.answers.push({
                id: null,
                text: '–ù–æ–≤—ã–π –æ—Ç–≤–µ—Ç',
                isCorrect: false,
                isPartial: false,
                points: 0,
                moodImpact: 0
            });

            saveState();
            renderNodes();
            showProperties(selectedNode);
        }

        function deleteAnswer(idx) {
            if (!selectedNode || !selectedNode.data.answers) return;
            if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –æ—Ç–≤–µ—Ç?')) return;

            selectedNode.data.answers.splice(idx, 1);
            saveState();
            renderNodes();
            showProperties(selectedNode);
        }

        function updateAnswer(idx, key, value) {
            if (!selectedNode || !selectedNode.data.answers || !selectedNode.data.answers[idx]) return;
            selectedNode.data.answers[idx][key] = value;
            saveState();
            renderNodes();
        }

        function setAnswerType(idx, type) {
            if (!selectedNode || !selectedNode.data.answers || !selectedNode.data.answers[idx]) return;

            const answer = selectedNode.data.answers[idx];
            answer.isCorrect = (type === 'correct');
            answer.isPartial = (type === 'partial');

            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–∑–Ω–∞—á–∞–µ–º –±–∞–ª–ª—ã
            if (type === 'correct') {
                answer.points = 10;
                answer.moodImpact = 10;
            } else if (type === 'partial') {
                answer.points = 5;
                answer.moodImpact = 0;
            } else {
                answer.points = 0;
                answer.moodImpact = -10;
            }

            saveState();
            renderNodes();
            showProperties(selectedNode);
        }

        // Add new node
        function addNode(type) {
            const scrollX = canvasContainer.scrollLeft;
            const scrollY = canvasContainer.scrollTop;

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É–∑–ª–∞
            let nodeData = {};
            switch(type) {
                case 'client':
                    nodeData = {
                        message: '–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞',
                        clientName: '–ö–ª–∏–µ–Ω—Ç',
                        mood: 'neutral',
                        answers: []
                    };
                    break;
                case 'answer':
                    nodeData = {
                        text: '–û—Ç–≤–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞',
                        isCorrect: false,
                        isPartial: false,
                        points: 0,
                        moodImpact: 0,
                        feedback: '',
                        knowledgeLink: ''
                    };
                    break;
                case 'condition':
                    nodeData = {
                        condition: 'if loyalty < 50%'
                    };
                    break;
                case 'end':
                    nodeData = {
                        endType: 'success'
                    };
                    break;
            }

            const newNode = {
                id: `node_${nodeIdCounter++}`,
                type: type,
                x: scrollX + 400,
                y: scrollY + 200,
                data: nodeData
            };

            nodes.push(newNode);
            saveState();
            renderNodes();
            updateConnections();
            selectNode(newNode);
        }

        // Delete node
        function deleteNode(nodeId) {
            if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç?')) return;

            nodes = nodes.filter(n => n.id !== nodeId);
            connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);

            if (selectedNode && selectedNode.id === nodeId) {
                selectedNode = null;
                panelEmpty.style.display = 'block';
                panelContent.style.display = 'none';
            }

            saveState();
            renderNodes();
            updateConnections();
        }

        // Zoom
        function zoomIn() {
            zoom = Math.min(2, zoom + 0.1);
            applyZoom();
        }

        function zoomOut() {
            zoom = Math.max(0.5, zoom - 0.1);
            applyZoom();
        }

        function applyZoom() {
            canvas.style.transform = `scale(${zoom})`;
            canvas.style.transformOrigin = 'top left';
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        // Mouse wheel zoom
        canvasContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        });

        // Save scenario
        async function saveScenario() {
            // Prepare nodes data for API
            const nodesData = nodes.map(n => ({
                id: n.id,
                type: n.type,
                x: n.x,
                y: n.y,
                label: n.data.message || n.data.condition || '',
                mood: n.data.mood || 'neutral',
                isCorrect: n.data.isCorrect || false,
                moodImpact: n.data.moodImpact || 0,
                feedback: n.data.feedback || '',
                knowledgeLink: n.data.knowledgeLink || '',
                answers: n.data.answers || []
            }));

            // Prepare connections data
            const connectionsData = connections.map(c => ({
                id: `conn_${c.from}_${c.to}`,
                fromId: c.from,
                toId: c.to
            }));

            const data = {
                nodes: nodesData,
                connections: connectionsData
            };

            try {
                const response = await fetch(`/admin/trainer/scenario/${scenarioId}/visual/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();

                if (result.success) {
                    showToast('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!', false);
                } else {
                    showToast('–û—à–∏–±–∫–∞: ' + result.error, true);
                }
            } catch (error) {
                showToast('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', true);
            }
        }

        // Toast
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Help
        function showHelp() {
            document.getElementById('helpOverlay').classList.add('show');
        }

        function hideHelp() {
            document.getElementById('helpOverlay').classList.remove('show');
        }

        // Click outside to deselect
        canvas.addEventListener('click', (e) => {
            if (e.target === canvas || e.target === connectionsSvg) {
                document.querySelectorAll('.node.selected').forEach(n => n.classList.remove('selected'));
                selectedNode = null;
                panelEmpty.style.display = 'block';
                panelContent.style.display = 'none';
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            if (e.key === 'Delete' && selectedNode) {
                deleteNode(selectedNode.id);
            }
            // Ctrl+S - Save
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                saveScenario();
            }
            // Ctrl+Z - Undo
            if (e.key === 'z' && (e.ctrlKey || e.metaKey) && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y or Ctrl+Shift+Z - Redo
            if ((e.key === 'y' && (e.ctrlKey || e.metaKey)) ||
                (e.key === 'z' && (e.ctrlKey || e.metaKey) && e.shiftKey)) {
                e.preventDefault();
                redo();
            }
            // Ctrl+C - Copy
            if (e.key === 'c' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                copyNode();
            }
            // Ctrl+V - Paste
            if (e.key === 'v' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                pasteNode();
            }
            // Ctrl+D - Duplicate
            if (e.key === 'd' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                duplicateNode();
            }
            if (e.key === 'Escape') {
                hideHelp();
            }
        });
    </script>
</body>
</html>
